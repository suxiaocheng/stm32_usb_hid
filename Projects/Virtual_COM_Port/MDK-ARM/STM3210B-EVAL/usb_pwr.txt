; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210B-EVAL\usb_pwr.o --depend=.\STM3210B-EVAL\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\STM3210B-EVAL\usb_pwr.crf ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;93     *******************************************************************************/
;;;94     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  4c06              LDR      r4,|L1.28|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  f04f0000          MOV      r0,#0
00000c  6060              STR      r0,[r4,#4]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  6020              STR      r0,[r4,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106    
;;;107      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;108    }
000018  bd10              POP      {r4,pc}
;;;109    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68       /*** cable plugged-in ? ***/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
000008  4807              LDR      r0,|L2.40|
00000a  2101              MOVS     r1,#1
;;;73       _SetCNTR(wRegVal);
00000c  6001              STR      r1,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  f04f0100          MOV      r1,#0
000012  4a06              LDR      r2,|L2.44|
;;;77       _SetCNTR(wInterrupt_Mask);
000014  6001              STR      r1,[r0,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
000016  6041              STR      r1,[r0,#4]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;83       
;;;84       return USB_SUCCESS;
000020  f04f0000          MOV      r0,#0
;;;85     }
000024  bd10              POP      {r4,pc}
;;;86     
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40005c40
                  |L2.44|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;258    *******************************************************************************/
;;;259    void Resume(RESUME_STATE eResumeSetVal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;260    {
;;;261      uint16_t wCNTR;
;;;262    
;;;263      if (eResumeSetVal != RESUME_ESOF)
;;;264        ResumeS.eState = eResumeSetVal;
000004  4c23              LDR      r4,|L3.148|
000006  2807              CMP      r0,#7                 ;263
000008  d000              BEQ      |L3.12|
00000a  7020              STRB     r0,[r4,#0]
                  |L3.12|
;;;265      switch (ResumeS.eState)
00000c  7820              LDRB     r0,[r4,#0]  ; ResumeS
;;;266      {
;;;267        case RESUME_EXTERNAL:
;;;268          if (remotewakeupon ==0)
00000e  4d21              LDR      r5,|L3.148|
;;;269          {
;;;270            Resume_Init();
;;;271            ResumeS.eState = RESUME_OFF;
000010  2606              MOVS     r6,#6
;;;272          }
;;;273          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;274          {
;;;275            ResumeS.eState = RESUME_ON;
000012  2205              MOVS     r2,#5
;;;276          }
;;;277          break;
;;;278        case RESUME_INTERNAL:
;;;279          Resume_Init();
;;;280          ResumeS.eState = RESUME_START;
000014  2704              MOVS     r7,#4
;;;281          remotewakeupon = 1;
;;;282          break;
;;;283        case RESUME_LATER:
;;;284          ResumeS.bESOFcnt = 2;
;;;285          ResumeS.eState = RESUME_WAIT;
;;;286          break;
;;;287        case RESUME_WAIT:
;;;288          ResumeS.bESOFcnt--;
;;;289          if (ResumeS.bESOFcnt == 0)
;;;290            ResumeS.eState = RESUME_START;
;;;291          break;
;;;292        case RESUME_START:
;;;293          wCNTR = _GetCNTR();
000016  4920              LDR      r1,|L3.152|
000018  2806              CMP      r0,#6                 ;265
00001a  d208              BCS      |L3.46|
00001c  e8dff000          TBB      [pc,r0]               ;265
000020  030c1116          DCB      0x03,0x0c,0x11,0x16
000024  1e29              DCB      0x1e,0x29
000026  6868              LDR      r0,[r5,#4]            ;268  ; remotewakeupon
000028  b920              CBNZ     r0,|L3.52|
00002a  f7fffffe          BL       Resume_Init
                  |L3.46|
;;;294          wCNTR |= CNTR_RESUME;
;;;295          _SetCNTR(wCNTR);
;;;296          ResumeS.eState = RESUME_ON;
;;;297          ResumeS.bESOFcnt = 10;
;;;298          break;
;;;299        case RESUME_ON:    
;;;300          ResumeS.bESOFcnt--;
;;;301          if (ResumeS.bESOFcnt == 0)
;;;302          {
;;;303            wCNTR = _GetCNTR();
;;;304            wCNTR &= (~CNTR_RESUME);
;;;305            _SetCNTR(wCNTR);
;;;306            ResumeS.eState = RESUME_OFF;
;;;307            remotewakeupon = 0;
;;;308          }
;;;309          break;
;;;310        case RESUME_OFF:
;;;311        case RESUME_ESOF:
;;;312        default:
;;;313          ResumeS.eState = RESUME_OFF;
00002e  7026              STRB     r6,[r4,#0]
                  |L3.48|
;;;314          break;
;;;315      }
;;;316    }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L3.52|
000034  7022              STRB     r2,[r4,#0]            ;275
000036  e7fb              B        |L3.48|
000038  f7fffffe          BL       Resume_Init
00003c  7027              STRB     r7,[r4,#0]            ;280
00003e  2001              MOVS     r0,#1                 ;281
000040  e026              B        |L3.144|
000042  2002              MOVS     r0,#2                 ;284
000044  7060              STRB     r0,[r4,#1]            ;284
000046  2003              MOVS     r0,#3                 ;285
000048  7020              STRB     r0,[r4,#0]            ;285
00004a  e7f1              B        |L3.48|
00004c  7860              LDRB     r0,[r4,#1]            ;288  ; ResumeS
00004e  1e40              SUBS     r0,r0,#1              ;288
000050  7060              STRB     r0,[r4,#1]            ;288
000052  7860              LDRB     r0,[r4,#1]            ;289  ; ResumeS
000054  2800              CMP      r0,#0                 ;289
000056  d1eb              BNE      |L3.48|
000058  7027              STRB     r7,[r4,#0]            ;290
00005a  e7e9              B        |L3.48|
00005c  f8d10c40          LDR      r0,[r1,#0xc40]        ;293
000060  b280              UXTH     r0,r0                 ;293
000062  f0400010          ORR      r0,r0,#0x10           ;294
000066  f8c10c40          STR      r0,[r1,#0xc40]        ;295
00006a  7022              STRB     r2,[r4,#0]            ;296
00006c  200a              MOVS     r0,#0xa               ;297
00006e  7060              STRB     r0,[r4,#1]            ;297
000070  e7de              B        |L3.48|
000072  7860              LDRB     r0,[r4,#1]            ;300  ; ResumeS
000074  1e40              SUBS     r0,r0,#1              ;300
000076  7060              STRB     r0,[r4,#1]            ;300
000078  7860              LDRB     r0,[r4,#1]            ;301  ; ResumeS
00007a  2800              CMP      r0,#0                 ;301
00007c  d1d8              BNE      |L3.48|
00007e  f8d10c40          LDR      r0,[r1,#0xc40]        ;303
000082  b280              UXTH     r0,r0                 ;303
000084  f0200010          BIC      r0,r0,#0x10           ;304
000088  f8c10c40          STR      r0,[r1,#0xc40]        ;305
00008c  7026              STRB     r6,[r4,#0]            ;306
00008e  2000              MOVS     r0,#0                 ;307
                  |L3.144|
000090  6068              STR      r0,[r5,#4]            ;281  ; remotewakeupon
000092  e7cd              B        |L3.48|
;;;317    
                          ENDP

                  |L3.148|
                          DCD      ||area_number.11||
                  |L3.152|
                          DCD      0x40005000

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;221    *******************************************************************************/
;;;222    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
000002  4c06              LDR      r4,|L4.28|
;;;224      uint16_t wCNTR;
;;;225      
;;;226      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;227      /* restart the clocks */
;;;228      /* ...  */
;;;229    
;;;230      /* CNTR_LPMODE = 0 */
;;;231      wCNTR = _GetCNTR();
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;232      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;233      _SetCNTR(wCNTR);    
00000c  6020              STR      r0,[r4,#0]
;;;234      
;;;235      /* restore full power */
;;;236      /* ... on connected devices */
;;;237      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;238    
;;;239      /* reset FSUSP bit */
;;;240      _SetCNTR(IMR_MSK);
000012  f44f403f          MOV      r0,#0xbf00
000016  6020              STR      r0,[r4,#0]
;;;241    
;;;242      /* reverse suspend preparation */
;;;243      /* ... */ 
;;;244    
;;;245    }
000018  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;116    *******************************************************************************/
;;;117    void Suspend(void)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119    	uint32_t i =0;
;;;120    	uint16_t wCNTR;
;;;121    	uint32_t tmpreg = 0;
;;;122      __IO uint32_t savePWR_CR=0;
;;;123    	/* suspend preparation */
;;;124    	/* ... */
;;;125    	
;;;126    	/*Store CNTR value */
;;;127    	wCNTR = _GetCNTR();  
000002  4932              LDR      r1,|L5.204|
000004  2000              MOVS     r0,#0                 ;119
000006  f8d12c40          LDR      r2,[r1,#0xc40]
00000a  b293              UXTH     r3,r2
;;;128    
;;;129        /* This a sequence to apply a force RESET to handle a robustness case */
;;;130        
;;;131    	/*Store endpoints registers status */
;;;132        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
00000c  4a30              LDR      r2,|L5.208|
00000e  bf00              NOP      
                  |L5.16|
000010  eb010480          ADD      r4,r1,r0,LSL #2
000014  f8d44c00          LDR      r4,[r4,#0xc00]
000018  b2a4              UXTH     r4,r4
00001a  f8424020          STR      r4,[r2,r0,LSL #2]
00001e  1c40              ADDS     r0,r0,#1
000020  2808              CMP      r0,#8
000022  d3f5              BCC      |L5.16|
;;;133    	
;;;134    	/* unmask RESET flag */
;;;135    	wCNTR|=CNTR_RESETM;
000024  f4436080          ORR      r0,r3,#0x400
;;;136    	_SetCNTR(wCNTR);
000028  f8c10c40          STR      r0,[r1,#0xc40]
;;;137    	
;;;138    	/*apply FRES */
;;;139    	wCNTR|=CNTR_FRES;
00002c  f0400001          ORR      r0,r0,#1
;;;140    	_SetCNTR(wCNTR);
000030  f8c10c40          STR      r0,[r1,#0xc40]
;;;141    	
;;;142    	/*clear FRES*/
;;;143    	wCNTR&=~CNTR_FRES;
000034  f0200301          BIC      r3,r0,#1
;;;144    	_SetCNTR(wCNTR);
000038  f8c13c40          STR      r3,[r1,#0xc40]
                  |L5.60|
;;;145    	
;;;146    	/*poll for RESET flag in ISTR*/
;;;147    	while((_GetISTR()&ISTR_RESET) == 0);
00003c  f8d10c44          LDR      r0,[r1,#0xc44]
000040  0540              LSLS     r0,r0,#21
000042  d5fb              BPL      |L5.60|
;;;148    	
;;;149    	/* clear RESET flag in ISTR */
;;;150    	_SetISTR((uint16_t)CLR_RESET);
000044  f64f30ff          MOV      r0,#0xfbff
000048  f8c10c44          STR      r0,[r1,#0xc44]
;;;151    	
;;;152    	/*restore Enpoints*/
;;;153    	for (i=0;i<8;i++)
00004c  f05f0000          MOVS.W   r0,#0
                  |L5.80|
;;;154    	_SetENDPOINT(i, EP[i]);
000050  f8524020          LDR      r4,[r2,r0,LSL #2]
000054  eb010580          ADD      r5,r1,r0,LSL #2
000058  b2a4              UXTH     r4,r4
00005a  f8c54c00          STR      r4,[r5,#0xc00]
00005e  1c40              ADDS     r0,r0,#1              ;153
000060  2808              CMP      r0,#8                 ;153
000062  d3f5              BCC      |L5.80|
;;;155    	
;;;156    	/* Now it is safe to enter macrocell in suspend mode */
;;;157    	wCNTR |= CNTR_FSUSP;
000064  f0430008          ORR      r0,r3,#8
;;;158    	_SetCNTR(wCNTR);
000068  f8c10c40          STR      r0,[r1,#0xc40]
;;;159    	
;;;160    	/* force low-power mode in the macrocell */
;;;161    	wCNTR = _GetCNTR();
00006c  f8d10c40          LDR      r0,[r1,#0xc40]
000070  b280              UXTH     r0,r0
;;;162    	wCNTR |= CNTR_LPMODE;
000072  f0400004          ORR      r0,r0,#4
;;;163    	_SetCNTR(wCNTR);
000076  f8c10c40          STR      r0,[r1,#0xc40]
;;;164    	
;;;165    	/*prepare entry in low power mode (STOP mode)*/
;;;166    	/* Select the regulator state in STOP mode*/
;;;167    	savePWR_CR = PWR->CR;
00007a  4816              LDR      r0,|L5.212|
00007c  6803              LDR      r3,[r0,#0]
;;;168    	tmpreg = PWR->CR;
00007e  6802              LDR      r2,[r0,#0]
;;;169    	/* Clear PDDS and LPDS bits */
;;;170    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000080  f0220203          BIC      r2,r2,#3
;;;171    	/* Set LPDS bit according to PWR_Regulator value */
;;;172    	tmpreg |= PWR_Regulator_LowPower;
000084  f0420201          ORR      r2,r2,#1
;;;173    	/* Store the new value */
;;;174    	PWR->CR = tmpreg;
000088  6002              STR      r2,[r0,#0]
;;;175    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176    #if defined (STM32F30X) || defined (STM32F37X)
;;;177            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;178    #else
;;;179            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
00008a  f04f22e0          MOV      r2,#0xe000e000
00008e  f8d24d10          LDR      r4,[r2,#0xd10]
000092  f0440404          ORR      r4,r4,#4
000096  f8c24d10          STR      r4,[r2,#0xd10]
;;;180    #endif
;;;181    	
;;;182    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;183    	if((_GetISTR()&ISTR_WKUP)==0)
00009a  f8d14c44          LDR      r4,[r1,#0xc44]
00009e  04e4              LSLS     r4,r4,#19
0000a0  d401              BMI      |L5.166|
;;;184    	{
;;;185    		__WFI();
0000a2  bf30              WFI      
;;;186    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;187    #if defined (STM32F30X) || defined (STM32F37X)
;;;188                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;189    #else
;;;190                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
0000a4  e00a              B        |L5.188|
                  |L5.166|
;;;191    #endif
;;;192    	}
;;;193    	else
;;;194    	{
;;;195    		/* Clear Wakeup flag */
;;;196    		_SetISTR(CLR_WKUP);
0000a6  f64e74ff          MOV      r4,#0xefff
0000aa  f5016144          ADD      r1,r1,#0xc40
0000ae  604c              STR      r4,[r1,#4]
;;;197    		/* clear FSUSP to abort entry in suspend mode  */
;;;198            wCNTR = _GetCNTR();
0000b0  680c              LDR      r4,[r1,#0]
0000b2  b2a4              UXTH     r4,r4
;;;199            wCNTR&=~CNTR_FSUSP;
0000b4  f0240408          BIC      r4,r4,#8
;;;200            _SetCNTR(wCNTR);
0000b8  600c              STR      r4,[r1,#0]
;;;201    		
;;;202    		/*restore sleep mode configuration */ 
;;;203    		/* restore Power regulator config in sleep mode*/
;;;204    		PWR->CR = savePWR_CR;
0000ba  6003              STR      r3,[r0,#0]
                  |L5.188|
0000bc  f8d20d10          LDR      r0,[r2,#0xd10]        ;190
0000c0  f0200004          BIC      r0,r0,#4              ;190
0000c4  f8c20d10          STR      r0,[r2,#0xd10]        ;190
;;;205    		
;;;206    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;207    #if defined (STM32F30X) || defined (STM32F37X)		
;;;208                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;209    #else
;;;210                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
;;;211    #endif
;;;212        }
;;;213    }
0000c8  bd30              POP      {r4,r5,pc}
;;;214    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L5.204|
                          DCD      0x40005000
                  |L5.208|
                          DCD      ||.bss||
                  |L5.212|
                          DCD      0x40007000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ResumeS
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000
