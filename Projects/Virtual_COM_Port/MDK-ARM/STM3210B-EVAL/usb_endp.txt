; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210B-EVAL\usb_endp.o --depend=.\STM3210B-EVAL\usb_endp.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\STM3210B-EVAL\usb_endp.crf ..\src\usb_endp.c]
                          THUMB

                          AREA ||i.EP1_IN_Callback||, CODE, READONLY, ALIGN=2

                  EP1_IN_Callback PROC
;;;60     *******************************************************************************/
;;;61     void EP1_IN_Callback (void)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63       uint16_t USB_Tx_ptr;
;;;64       uint16_t USB_Tx_length;
;;;65       
;;;66       if (USB_Tx_State == 1)
000002  4914              LDR      r1,|L1.84|
000004  7808              LDRB     r0,[r1,#0]  ; USB_Tx_State
000006  2801              CMP      r0,#1
000008  d104              BNE      |L1.20|
;;;67       {
;;;68         if (USART_Rx_length == 0) 
00000a  4e13              LDR      r6,|L1.88|
00000c  2500              MOVS     r5,#0
00000e  6830              LDR      r0,[r6,#0]  ; USART_Rx_length
000010  b908              CBNZ     r0,|L1.22|
;;;69         {
;;;70           USB_Tx_State = 0;
000012  700d              STRB     r5,[r1,#0]
                  |L1.20|
;;;71         }
;;;72         else 
;;;73         {
;;;74           if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE){
;;;75             USB_Tx_ptr = USART_Rx_ptr_out;
;;;76             USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
;;;77             
;;;78             USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;
;;;79             USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;    
;;;80           }
;;;81           else 
;;;82           {
;;;83             USB_Tx_ptr = USART_Rx_ptr_out;
;;;84             USB_Tx_length = USART_Rx_length;
;;;85             
;;;86             USART_Rx_ptr_out += USART_Rx_length;
;;;87             USART_Rx_length = 0;
;;;88           }
;;;89           UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
;;;90           SetEPTxCount(ENDP1, USB_Tx_length);
;;;91           SetEPTxValid(ENDP1); 
;;;92         }
;;;93       }
;;;94     }
000014  bd70              POP      {r4-r6,pc}
                  |L1.22|
000016  4b11              LDR      r3,|L1.92|
000018  2840              CMP      r0,#0x40              ;74
00001a  6819              LDR      r1,[r3,#0]            ;74
00001c  b28a              UXTH     r2,r1                 ;75
00001e  d905              BLS      |L1.44|
000020  3140              ADDS     r1,r1,#0x40           ;78
000022  2440              MOVS     r4,#0x40              ;76
000024  3840              SUBS     r0,r0,#0x40           ;79
000026  6019              STR      r1,[r3,#0]            ;79  ; USART_Rx_ptr_out
000028  6030              STR      r0,[r6,#0]            ;79  ; USART_Rx_length
00002a  e003              B        |L1.52|
                  |L1.44|
00002c  b284              UXTH     r4,r0                 ;84
00002e  4408              ADD      r0,r0,r1              ;86
000030  6018              STR      r0,[r3,#0]            ;87  ; USART_Rx_ptr_out
000032  6035              STR      r5,[r6,#0]            ;87  ; USART_Rx_length
                  |L1.52|
000034  480a              LDR      r0,|L1.96|
000036  21c0              MOVS     r1,#0xc0              ;89
000038  4410              ADD      r0,r0,r2              ;89
00003a  4622              MOV      r2,r4                 ;89
00003c  f7fffffe          BL       UserToPMABufferCopy
000040  4621              MOV      r1,r4                 ;90
000042  2001              MOVS     r0,#1                 ;90
000044  f7fffffe          BL       SetEPTxCount
000048  e8bd4070          POP      {r4-r6,lr}            ;91
00004c  2001              MOVS     r0,#1                 ;91
00004e  f7ffbffe          B.W      SetEPTxValid
;;;95     
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      USB_Tx_State
                  |L1.88|
                          DCD      USART_Rx_length
                  |L1.92|
                          DCD      USART_Rx_ptr_out
                  |L1.96|
                          DCD      USART_Rx_Buffer

                          AREA ||i.EP3_OUT_Callback||, CODE, READONLY, ALIGN=2

                  EP3_OUT_Callback PROC
;;;102    *******************************************************************************/
;;;103    void EP3_OUT_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105      uint16_t USB_Rx_Cnt;
;;;106      
;;;107      /* Get the received data buffer and update the counter */
;;;108      USB_Rx_Cnt = USB_SIL_Read(EP3_OUT, USB_Rx_Buffer);
000002  4906              LDR      r1,|L2.28|
000004  2003              MOVS     r0,#3
000006  f7fffffe          BL       USB_SIL_Read
;;;109      
;;;110      /* USB data will be immediately processed, this allow next USB traffic being 
;;;111      NAKed till the end of the USART Xfer */
;;;112      
;;;113      USB_To_USART_Send_Data(USB_Rx_Buffer, USB_Rx_Cnt);
00000a  b2c1              UXTB     r1,r0
00000c  4803              LDR      r0,|L2.28|
00000e  f7fffffe          BL       USB_To_USART_Send_Data
;;;114     
;;;115      /* Enable the receive of data on EP3 */
;;;116      SetEPRxValid(ENDP3);
000012  e8bd4010          POP      {r4,lr}
000016  2003              MOVS     r0,#3
000018  f7ffbffe          B.W      SetEPRxValid
;;;117    }
;;;118    
                          ENDP

                  |L2.28|
                          DCD      ||.bss||

                          AREA ||i.SOF_Callback||, CODE, READONLY, ALIGN=2

                  SOF_Callback PROC
;;;126    *******************************************************************************/
;;;127    void SOF_Callback(void)
000000  4807              LDR      r0,|L3.32|
;;;128    {
;;;129      static uint32_t FrameCount = 0;
;;;130      
;;;131      if(bDeviceState == CONFIGURED)
000002  6800              LDR      r0,[r0,#0]  ; bDeviceState
000004  2805              CMP      r0,#5
000006  d109              BNE      |L3.28|
;;;132      {
;;;133        if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
000008  4906              LDR      r1,|L3.36|
00000a  6808              LDR      r0,[r1,#0]  ; FrameCount
00000c  1c40              ADDS     r0,r0,#1
00000e  6008              STR      r0,[r1,#0]  ; FrameCount
000010  2806              CMP      r0,#6
000012  d103              BNE      |L3.28|
;;;134        {
;;;135          /* Reset the frame counter */
;;;136          FrameCount = 0;
000014  2000              MOVS     r0,#0
;;;137          
;;;138          /* Check the data to be sent through IN pipe */
;;;139          Handle_USBAsynchXfer();
000016  6008              STR      r0,[r1,#0]  ; FrameCount
000018  f7ffbffe          B.W      Handle_USBAsynchXfer
                  |L3.28|
;;;140        }
;;;141      }  
;;;142    }
00001c  4770              BX       lr
;;;143    /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      bDeviceState
                  |L3.36|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USB_Rx_Buffer
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  FrameCount
                          DCD      0x00000000
