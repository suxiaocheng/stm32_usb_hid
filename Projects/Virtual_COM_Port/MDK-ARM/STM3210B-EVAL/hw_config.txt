; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210B-EVAL\hw_config.o --depend=.\STM3210B-EVAL\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\STM3210B-EVAL\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;171    *******************************************************************************/
;;;172    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L1.8|
;;;173    {
;;;174      /* Set the device state to suspend */
;;;175      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;515    *******************************************************************************/
;;;516    void Get_SerialNum(void)
000000  b510              PUSH     {r4,lr}
;;;517    {
000002  4809              LDR      r0,|L2.40|
;;;518      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;519    
;;;520      Device_Serial0 = *(uint32_t*)ID1;
;;;521      Device_Serial1 = *(uint32_t*)ID2;
;;;522      Device_Serial2 = *(uint32_t*)ID3;  
000004  e9d01400          LDRD     r1,r4,[r0,#0]
000008  6880              LDR      r0,[r0,#8]
;;;523    
;;;524      Device_Serial0 += Device_Serial2;
00000a  1808              ADDS     r0,r1,r0
;;;525    
;;;526      if (Device_Serial0 != 0)
00000c  d00b              BEQ      |L2.38|
;;;527      {
;;;528        IntToUnicode (Device_Serial0, &Virtual_Com_Port_StringSerial[2] , 8);
00000e  2208              MOVS     r2,#8
000010  4906              LDR      r1,|L2.44|
000012  f7fffffe          BL       IntToUnicode
;;;529        IntToUnicode (Device_Serial1, &Virtual_Com_Port_StringSerial[18], 4);
000016  4905              LDR      r1,|L2.44|
000018  4620              MOV      r0,r4
00001a  2204              MOVS     r2,#4
00001c  e8bd4010          POP      {r4,lr}
000020  3110              ADDS     r1,r1,#0x10
000022  f7ffbffe          B.W      IntToUnicode
                  |L2.38|
;;;530      }
;;;531    }
000026  bd10              POP      {r4,pc}
;;;532    
                          ENDP

                  |L2.40|
                          DCD      0x1ffff7e8
                  |L2.44|
                          DCD      Virtual_Com_Port_StringSerial+0x2

                          AREA ||i.Handle_USBAsynchXfer||, CODE, READONLY, ALIGN=2

                  Handle_USBAsynchXfer PROC
;;;430    *******************************************************************************/
;;;431    void Handle_USBAsynchXfer (void)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
;;;433      
;;;434      uint16_t USB_Tx_ptr;
;;;435      uint16_t USB_Tx_length;
;;;436      
;;;437      if(USB_Tx_State != 1)
000002  4b1a              LDR      r3,|L3.108|
000004  7818              LDRB     r0,[r3,#0]  ; USB_Tx_State
000006  2801              CMP      r0,#1
000008  d00a              BEQ      |L3.32|
;;;438      {
;;;439        if (USART_Rx_ptr_out == USART_RX_DATA_SIZE)
00000a  6898              LDR      r0,[r3,#8]  ; USART_Rx_ptr_out
;;;440        {
;;;441          USART_Rx_ptr_out = 0;
00000c  2500              MOVS     r5,#0
00000e  f5b06f00          CMP      r0,#0x800             ;439
000012  d100              BNE      |L3.22|
000014  609d              STR      r5,[r3,#8]  ; USART_Rx_ptr_out
                  |L3.22|
;;;442        }
;;;443        
;;;444        if(USART_Rx_ptr_out == USART_Rx_ptr_in) 
000016  e9d31001          LDRD     r1,r0,[r3,#4]
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L3.34|
;;;445        {
;;;446          USB_Tx_State = 0; 
00001e  701d              STRB     r5,[r3,#0]
                  |L3.32|
;;;447          return;
;;;448        }
;;;449        
;;;450        if(USART_Rx_ptr_out > USART_Rx_ptr_in) /* rollback */
;;;451        { 
;;;452          USART_Rx_length = USART_RX_DATA_SIZE - USART_Rx_ptr_out;
;;;453        }
;;;454        else 
;;;455        {
;;;456          USART_Rx_length = USART_Rx_ptr_in - USART_Rx_ptr_out;
;;;457        }
;;;458        
;;;459        if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE)
;;;460        {
;;;461          USB_Tx_ptr = USART_Rx_ptr_out;
;;;462          USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
;;;463          
;;;464          USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;	
;;;465          USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;	
;;;466        }
;;;467        else
;;;468        {
;;;469          USB_Tx_ptr = USART_Rx_ptr_out;
;;;470          USB_Tx_length = USART_Rx_length;
;;;471          
;;;472          USART_Rx_ptr_out += USART_Rx_length;
;;;473          USART_Rx_length = 0;
;;;474        }
;;;475        USB_Tx_State = 1; 
;;;476        UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
;;;477        SetEPTxCount(ENDP1, USB_Tx_length);
;;;478        SetEPTxValid(ENDP1); 
;;;479      }  
;;;480      
;;;481    }
000020  bd70              POP      {r4-r6,pc}
                  |L3.34|
000022  d902              BLS      |L3.42|
000024  f5c06100          RSB      r1,r0,#0x800          ;452
000028  e000              B        |L3.44|
                  |L3.42|
00002a  1a09              SUBS     r1,r1,r0              ;456
                  |L3.44|
00002c  60d9              STR      r1,[r3,#0xc]          ;459  ; USART_Rx_length
00002e  2940              CMP      r1,#0x40              ;459
000030  b282              UXTH     r2,r0                 ;461
000032  d905              BLS      |L3.64|
000034  2440              MOVS     r4,#0x40              ;462
000036  3040              ADDS     r0,r0,#0x40           ;464
000038  3940              SUBS     r1,r1,#0x40           ;465
00003a  e9c30102          STRD     r0,r1,[r3,#8]         ;465
00003e  e003              B        |L3.72|
                  |L3.64|
000040  4408              ADD      r0,r0,r1              ;472
000042  e9c30502          STRD     r0,r5,[r3,#8]         ;473
000046  b28c              UXTH     r4,r1                 ;470
                  |L3.72|
000048  2001              MOVS     r0,#1                 ;475
00004a  7018              STRB     r0,[r3,#0]            ;475
00004c  4808              LDR      r0,|L3.112|
00004e  21c0              MOVS     r1,#0xc0              ;476
000050  4410              ADD      r0,r0,r2              ;476
000052  4622              MOV      r2,r4                 ;476
000054  f7fffffe          BL       UserToPMABufferCopy
000058  4621              MOV      r1,r4                 ;477
00005a  2001              MOVS     r0,#1                 ;477
00005c  f7fffffe          BL       SetEPTxCount
000060  e8bd4070          POP      {r4-r6,lr}            ;478
000064  2001              MOVS     r0,#1                 ;478
000066  f7ffbffe          B.W      SetEPTxValid
;;;482    /*******************************************************************************
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      ||.data||
                  |L3.112|
                          DCD      ||.bss||+0x10

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;539    *******************************************************************************/
;;;540    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;541    {
;;;542      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;543      
;;;544      for( idx = 0 ; idx < len ; idx ++)
;;;545      {
;;;546        if( ((value >> 28)) < 0xA )
000004  250a              MOVS     r5,#0xa
;;;547        {
;;;548          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2630              MOVS     r6,#0x30
;;;549        }
;;;550        else
;;;551        {
;;;552          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  f04f0c37          MOV      r12,#0x37
00000c  461f              MOV      r7,r3                 ;542
00000e  e00f              B        |L4.48|
                  |L4.16|
000010  ebb57f10          CMP      r5,r0,LSR #28         ;546
000014  d902              BLS      |L4.28|
000016  eb067410          ADD      r4,r6,r0,LSR #28      ;548
00001a  e001              B        |L4.32|
                  |L4.28|
00001c  eb0c7410          ADD      r4,r12,r0,LSR #28
                  |L4.32|
000020  f8014013          STRB     r4,[r1,r3,LSL #1]
;;;553        }
;;;554        
;;;555        value = value << 4;
;;;556        
;;;557        pbuf[ 2* idx + 1] = 0;
000024  eb010443          ADD      r4,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;555
00002a  1c5b              ADDS     r3,r3,#1              ;544
00002c  7067              STRB     r7,[r4,#1]
00002e  b2db              UXTB     r3,r3                 ;544
                  |L4.48|
000030  4293              CMP      r3,r2                 ;544
000032  d3ed              BCC      |L4.16|
;;;558      }
;;;559    }
000034  bdf0              POP      {r4-r7,pc}
;;;560    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;183    *******************************************************************************/
;;;184    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L5.20|
;;;185    {
;;;186      DEVICE_INFO *pInfo = &Device_Info;
;;;187    
;;;188      /* Set the device state to the correct state */
;;;189      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;190      {
;;;191        /* Device configured */
;;;192        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L5.24|
000006  b109              CBZ      r1,|L5.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L5.14|
                  |L5.12|
;;;193      }
;;;194      else
;;;195      {
;;;196        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L5.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;197      }
;;;198      /*Enable SystemCoreClock*/
;;;199      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;200    }
;;;201    
                          ENDP

                  |L5.20|
                          DCD      Device_Info
                  |L5.24|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;64     *******************************************************************************/
;;;65     void Set_System(void)
000000  b538              PUSH     {r3-r5,lr}
;;;66     {
;;;67     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)
;;;68       GPIO_InitTypeDef GPIO_InitStructure;
;;;69     #endif /* STM32L1XX_MD && STM32L1XX_XD */  
;;;70     
;;;71     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;72       GPIO_InitTypeDef  GPIO_InitStructure;
;;;73     #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;74       
;;;75       /*!< At this stage the microcontroller clock setting is already configured, 
;;;76            this is done through SystemInit() function which is called from startup
;;;77            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;78            To reconfigure the default setting of SystemInit() function, refer to
;;;79            system_stm32f10x.c file
;;;80          */   
;;;81     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;82       /* Enable the SYSCFG module clock */
;;;83       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;84     #endif /* STM32L1XX_XD */ 
;;;85        
;;;86     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS) && !defined(STM32F37X) && !defined(STM32F30X)
;;;87       /* Enable USB_DISCONNECT GPIO clock */
;;;88       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;89     
;;;90       /* Configure USB pull-up pin */
;;;91       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
00000a  f44f7000          MOV      r0,#0x200
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;92       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;93       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000018  2014              MOVS     r0,#0x14
00001a  f88d0003          STRB     r0,[sp,#3]
;;;94       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4808              LDR      r0,|L6.68|
000022  f7fffffe          BL       GPIO_Init
;;;95     #endif /* STM32L1XX_MD && STM32L1XX_XD */
;;;96        
;;;97     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;98       /* Enable the USB disconnect GPIO clock */
;;;99       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;100    
;;;101      /* USB_DISCONNECT used as USB pull-up */
;;;102      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;103      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;104      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;105      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;106      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;107      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;108    #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;109      
;;;110    #if defined(STM32F37X) || defined(STM32F30X)
;;;111      
;;;112      /* Enable the USB disconnect GPIO clock */
;;;113      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;114      
;;;115      /*Set PA11,12 as IN - USB_DM,DP*/
;;;116      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;117      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;118      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;119      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;120      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;121      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;122      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;123      
;;;124      /*SET PA11,12 for USB: USB_DM,DP*/
;;;125      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;126      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;127      
;;;128      /* USB_DISCONNECT used as USB pull-up */
;;;129      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;130      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;131      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;132      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;133      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;134      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;135    #endif /* STM32F37X && STM32F30X */ 
;;;136      
;;;137      /* Configure the EXTI line 18 connected internally to the USB IP */
;;;138      EXTI_ClearITPendingBit(EXTI_Line18);
000026  f44f2480          MOV      r4,#0x40000
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;139      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000030  4805              LDR      r0,|L6.72|
;;;140      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000032  2108              MOVS     r1,#8
000034  6004              STR      r4,[r0,#0]  ; EXTI_InitStructure
000036  7141              STRB     r1,[r0,#5]
;;;141      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000038  2101              MOVS     r1,#1
00003a  7181              STRB     r1,[r0,#6]
;;;142      EXTI_Init(&EXTI_InitStructure);
00003c  f7fffffe          BL       EXTI_Init
;;;143    }
000040  bd38              POP      {r3-r5,pc}
;;;144    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x40011400
                  |L6.72|
                          DCD      ||.data||+0x10

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;150    *******************************************************************************/
;;;151    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS) 
;;;154      /* Enable USB clock */
;;;155      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;156      
;;;157    #else 
;;;158      /* Select USBCLK source */
;;;159      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;160      
;;;161      /* Enable the USB clock */
;;;162      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;163    #endif /* STM32L1XX_MD */
;;;164    }
;;;165    
                          ENDP


                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;329    *******************************************************************************/
;;;330    bool USART_Config(void)
000000  b510              PUSH     {r4,lr}
;;;331    {
;;;332    
;;;333      /* set the Stop bit*/
;;;334      switch (linecoding.format)
000002  4b1c              LDR      r3,|L8.116|
;;;335      {
;;;336        case 0:
;;;337          USART_InitStructure.USART_StopBits = USART_StopBits_1;
000004  481c              LDR      r0,|L8.120|
000006  7919              LDRB     r1,[r3,#4]            ;334  ; linecoding
000008  2200              MOVS     r2,#0                 ;334
00000a  b1b9              CBZ      r1,|L8.60|
00000c  2901              CMP      r1,#1                 ;334
00000e  d017              BEQ      |L8.64|
000010  2902              CMP      r1,#2                 ;334
000012  d12b              BNE      |L8.108|
;;;338          break;
;;;339        case 1:
;;;340          USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
;;;341          break;
;;;342        case 2:
;;;343          USART_InitStructure.USART_StopBits = USART_StopBits_2;
000014  0309              LSLS     r1,r1,#12
                  |L8.22|
000016  80c1              STRH     r1,[r0,#6]            ;340
                  |L8.24|
;;;344          break;
;;;345        default :
;;;346        {
;;;347          USART_Config_Default();
;;;348          return (FALSE);
;;;349        }
;;;350      }
;;;351    
;;;352      /* set the parity bit*/
;;;353      switch (linecoding.paritytype)
000018  7959              LDRB     r1,[r3,#5]  ; linecoding
00001a  b1a1              CBZ      r1,|L8.70|
00001c  2901              CMP      r1,#1
00001e  d014              BEQ      |L8.74|
000020  2902              CMP      r1,#2
000022  d123              BNE      |L8.108|
;;;354      {
;;;355        case 0:
;;;356          USART_InitStructure.USART_Parity = USART_Parity_No;
;;;357          break;
;;;358        case 1:
;;;359          USART_InitStructure.USART_Parity = USART_Parity_Even;
;;;360          break;
;;;361        case 2:
;;;362          USART_InitStructure.USART_Parity = USART_Parity_Odd;
000024  f44f61c0          MOV      r1,#0x600
                  |L8.40|
000028  8101              STRH     r1,[r0,#8]            ;359
                  |L8.42|
;;;363          break;
;;;364        default :
;;;365        {
;;;366          USART_Config_Default();
;;;367          return (FALSE);
;;;368        }
;;;369      }
;;;370    
;;;371      /*set the data type : only 8bits and 9bits is supported */
;;;372      switch (linecoding.datatype)
00002a  7999              LDRB     r1,[r3,#6]  ; linecoding
00002c  2907              CMP      r1,#7
00002e  d003              BEQ      |L8.56|
000030  2908              CMP      r1,#8
000032  d11b              BNE      |L8.108|
;;;373      {
;;;374        case 0x07:
;;;375          /* With this configuration a parity (Even or Odd) should be set */
;;;376          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;377          break;
;;;378        case 0x08:
;;;379          if (USART_InitStructure.USART_Parity == USART_Parity_No)
000034  8901              LDRH     r1,[r0,#8]  ; USART_InitStructure
000036  b959              CBNZ     r1,|L8.80|
                  |L8.56|
;;;380          {
;;;381            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000038  8082              STRH     r2,[r0,#4]
00003a  e00c              B        |L8.86|
                  |L8.60|
00003c  80c2              STRH     r2,[r0,#6]            ;337
00003e  e7eb              B        |L8.24|
                  |L8.64|
000040  f44f5140          MOV      r1,#0x3000            ;340
000044  e7e7              B        |L8.22|
                  |L8.70|
000046  8102              STRH     r2,[r0,#8]            ;356
000048  e7ef              B        |L8.42|
                  |L8.74|
00004a  f44f6180          MOV      r1,#0x400             ;359
00004e  e7eb              B        |L8.40|
                  |L8.80|
;;;382          }
;;;383          else 
;;;384          {
;;;385            USART_InitStructure.USART_WordLength = USART_WordLength_9b;
000050  f44f5180          MOV      r1,#0x1000
000054  8081              STRH     r1,[r0,#4]
                  |L8.86|
;;;386          }
;;;387          
;;;388          break;
;;;389        default :
;;;390        {
;;;391          USART_Config_Default();
;;;392          return (FALSE);
;;;393        }
;;;394      }
;;;395    
;;;396      USART_InitStructure.USART_BaudRate = linecoding.bitrate;
000056  6819              LDR      r1,[r3,#0]  ; linecoding
;;;397      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000058  6001              STR      r1,[r0,#0]  ; USART_InitStructure
00005a  8182              STRH     r2,[r0,#0xc]
;;;398      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005c  210c              MOVS     r1,#0xc
00005e  8141              STRH     r1,[r0,#0xa]
;;;399     
;;;400      /* Configure and enable the USART */
;;;401      STM_EVAL_COMInit(COM1, &USART_InitStructure);
000060  4905              LDR      r1,|L8.120|
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       STM_EVAL_COMInit
;;;402    
;;;403      return (TRUE);
000068  2001              MOVS     r0,#1
;;;404    }
00006a  bd10              POP      {r4,pc}
                  |L8.108|
00006c  f7fffffe          BL       USART_Config_Default
000070  2000              MOVS     r0,#0                 ;392
000072  bd10              POP      {r4,pc}
;;;405    
                          ENDP

                  |L8.116|
                          DCD      linecoding
                  |L8.120|
                          DCD      ||.bss||

                          AREA ||i.USART_Config_Default||, CODE, READONLY, ALIGN=2

                  USART_Config_Default PROC
;;;296    *******************************************************************************/
;;;297    void USART_Config_Default(void)
000000  b510              PUSH     {r4,lr}
;;;298    {
;;;299      /* EVAL_COM1 default configuration */
;;;300      /* EVAL_COM1 configured as follow:
;;;301            - BaudRate = 9600 baud  
;;;302            - Word Length = 8 Bits
;;;303            - One Stop Bit
;;;304            - Parity Odd
;;;305            - Hardware flow control disabled
;;;306            - Receive and transmit enabled
;;;307      */
;;;308      USART_InitStructure.USART_BaudRate = 9600;
000002  480c              LDR      r0,|L9.52|
000004  f44f5116          MOV      r1,#0x2580
;;;309      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000008  6001              STR      r1,[r0,#0]  ; USART_InitStructure
00000a  2100              MOVS     r1,#0
00000c  8081              STRH     r1,[r0,#4]
;;;310      USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000e  80c1              STRH     r1,[r0,#6]
;;;311      USART_InitStructure.USART_Parity = USART_Parity_Odd;
000010  f44f62c0          MOV      r2,#0x600
000014  8102              STRH     r2,[r0,#8]
;;;312      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000016  8181              STRH     r1,[r0,#0xc]
;;;313      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  210c              MOVS     r1,#0xc
00001a  8141              STRH     r1,[r0,#0xa]
;;;314    
;;;315      /* Configure and enable the USART */
;;;316      STM_EVAL_COMInit(COM1, &USART_InitStructure);
00001c  4601              MOV      r1,r0
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       STM_EVAL_COMInit
;;;317    
;;;318      /* Enable the USART Receive interrupt */
;;;319      USART_ITConfig(EVAL_COM1, USART_IT_RXNE, ENABLE);
000024  e8bd4010          POP      {r4,lr}
000028  2201              MOVS     r2,#1
00002a  f2405125          MOV      r1,#0x525
00002e  4802              LDR      r0,|L9.56|
000030  f7ffbffe          B.W      USART_ITConfig
;;;320    }
;;;321    
                          ENDP

                  |L9.52|
                          DCD      ||.bss||
                  |L9.56|
                          DCD      0x40013800

                          AREA ||i.USART_To_USB_Send_Data||, CODE, READONLY, ALIGN=2

                  USART_To_USB_Send_Data PROC
;;;487    *******************************************************************************/
;;;488    void USART_To_USB_Send_Data(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490      
;;;491      if (linecoding.datatype == 7)
000002  480d              LDR      r0,|L10.56|
;;;492      {
;;;493        USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1) & 0x7F;
000004  4d0e              LDR      r5,|L10.64|
000006  7981              LDRB     r1,[r0,#6]            ;491  ; linecoding
000008  480c              LDR      r0,|L10.60|
00000a  4c0e              LDR      r4,|L10.68|
00000c  2907              CMP      r1,#7                 ;491
00000e  d104              BNE      |L10.26|
000010  f7fffffe          BL       USART_ReceiveData
000014  f000007f          AND      r0,r0,#0x7f
000018  e003              B        |L10.34|
                  |L10.26|
;;;494      }
;;;495      else if (linecoding.datatype == 8)
00001a  2908              CMP      r1,#8
00001c  d103              BNE      |L10.38|
;;;496      {
;;;497        USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1);
00001e  f7fffffe          BL       USART_ReceiveData
                  |L10.34|
000022  6861              LDR      r1,[r4,#4]  ; USART_Rx_ptr_in
000024  5468              STRB     r0,[r5,r1]
                  |L10.38|
;;;498      }
;;;499      
;;;500      USART_Rx_ptr_in++;
000026  6860              LDR      r0,[r4,#4]  ; USART_Rx_ptr_in
000028  1c40              ADDS     r0,r0,#1
;;;501      
;;;502      /* To avoid buffer overflow */
;;;503      if(USART_Rx_ptr_in == USART_RX_DATA_SIZE)
00002a  6060              STR      r0,[r4,#4]  ; USART_Rx_ptr_in
00002c  f5b06f00          CMP      r0,#0x800
000030  d101              BNE      |L10.54|
;;;504      {
;;;505        USART_Rx_ptr_in = 0;
000032  2000              MOVS     r0,#0
000034  6060              STR      r0,[r4,#4]  ; USART_Rx_ptr_in
                  |L10.54|
;;;506      }
;;;507    }
000036  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  |L10.56|
                          DCD      linecoding
                  |L10.60|
                          DCD      0x40013800
                  |L10.64|
                          DCD      ||.bss||+0x10
                  |L10.68|
                          DCD      ||.data||

                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;266    *******************************************************************************/
;;;267    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;268    {
;;;269    #if defined(STM32L1XX_MD) || defined (STM32L1XX_HD)|| (STM32L1XX_MD_PLUS)
;;;270      if (NewState != DISABLE)
;;;271      {
;;;272        STM32L15_USB_CONNECT;
;;;273      }
;;;274      else
;;;275      {
;;;276        STM32L15_USB_DISCONNECT;
;;;277      }  
;;;278      
;;;279    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;280      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;281      {
;;;282        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f7100          MOV      r1,#0x200
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L11.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L11.16|
;;;283      }
;;;284      else
;;;285      {
;;;286        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000010  f7ffbffe          B.W      GPIO_SetBits
;;;287      }
;;;288    #endif /* STM32L1XX_MD */
;;;289    }
;;;290    
                          ENDP

                  |L11.20|
                          DCD      0x40011400

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;207    *******************************************************************************/
;;;208    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;209    {
;;;210      NVIC_InitTypeDef NVIC_InitStructure; 
;;;211      
;;;212      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;213      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;214      
;;;215    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;216      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;217      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;218      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;219      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;220      NVIC_Init(&NVIC_InitStructure);
;;;221      
;;;222        /* Enable the USB Wake-up interrupt */
;;;223      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;224      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;225      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;226      NVIC_Init(&NVIC_InitStructure);
;;;227      
;;;228    #elif defined(STM32F37X)
;;;229      /* Enable the USB interrupt */
;;;230      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;231      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;232      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;233      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;234      NVIC_Init(&NVIC_InitStructure);
;;;235      
;;;236      /* Enable the USB Wake-up interrupt */
;;;237      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;238      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;239      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;240      NVIC_Init(&NVIC_InitStructure);
;;;241      
;;;242    #else
;;;243      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;244      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;245      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;246      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;247      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;248      
;;;249        /* Enable the USB Wake-up interrupt */
;;;250      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;251      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;252      NVIC_Init(&NVIC_InitStructure);
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       NVIC_Init
;;;253    #endif /* STM32L1XX_XD */
;;;254    
;;;255      /* Enable USART Interrupt */
;;;256      NVIC_InitStructure.NVIC_IRQChannel = EVAL_COM1_IRQn;
000038  2025              MOVS     r0,#0x25
00003a  f88d0000          STRB     r0,[sp,#0]
;;;257      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00003e  f88d5001          STRB     r5,[sp,#1]
;;;258      NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;259    }
000048  bd38              POP      {r3-r5,pc}
;;;260    
                          ENDP


                          AREA ||i.USB_To_USART_Send_Data||, CODE, READONLY, ALIGN=2

                  USB_To_USART_Send_Data PROC
;;;412    *******************************************************************************/
;;;413    void USB_To_USART_Send_Data(uint8_t* data_buffer, uint8_t Nb_bytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;415      
;;;416      uint32_t i;
;;;417      
;;;418      for (i = 0; i < Nb_bytes; i++)
000008  2400              MOVS     r4,#0
;;;419      {
;;;420        USART_SendData(EVAL_COM1, *(data_buffer + i));
00000a  4f08              LDR      r7,|L13.44|
00000c  e00a              B        |L13.36|
                  |L13.14|
00000e  5d29              LDRB     r1,[r5,r4]
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       USART_SendData
                  |L13.22|
;;;421        while(USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TXE) == RESET); 
000016  2180              MOVS     r1,#0x80
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       USART_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L13.22|
000022  1c64              ADDS     r4,r4,#1              ;418
                  |L13.36|
000024  42b4              CMP      r4,r6                 ;418
000026  d3f2              BCC      |L13.14|
;;;422      }  
;;;423    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;424    
                          ENDP

                  |L13.44|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16
                  USART_Rx_Buffer
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  USB_Tx_State
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  USART_Rx_ptr_in
                          DCD      0x00000000
                  USART_Rx_ptr_out
                          DCD      0x00000000
                  USART_Rx_length
                          DCD      0x00000000
                  EXTI_InitStructure
                          %        8

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  HSEStartUpStatus
000000  00                DCB      0x00
